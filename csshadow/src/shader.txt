const char *depthVertexShader = R"(
#version 300 es
precision highp float;
layout (location = 0) in vec3 aPos;

uniform mat4 lightSpaceMatrix;
uniform mat4 model;

void main()
{
    gl_Position = lightSpaceMatrix * model * vec4(aPos, 1.0);
}
)";

const char *depthFragmentShader = R"(
#version 300 es
precision highp float;

void main()
{             
}
)";

const char *debugVertexShader = R"(
#version 300 es
precision highp float;
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoords;

out vec2 TexCoords;

void main()
{
    TexCoords = aTexCoords;
    gl_Position = vec4(aPos, 1.0);
}
)";

const char *debugFragmentShader = R"(
#version 300 es
precision highp float;
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D depthMap;

void main()
{             
    float depthValue = texture(depthMap, TexCoords).r;
    FragColor = vec4(vec3(depthValue), 1.0);
}
)";

const char *shadowVertexShader = R"(
#version 300 es
precision highp float;
 
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoords;
out vec4 FragPosViewSpace;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = transpose(inverse(mat3(model))) * aNormal;
    TexCoords = aTexCoords;
    FragPosViewSpace = view * vec4(FragPos, 1.0);
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
)";

const char *shadowFragmentShader = R"(
#version 300 es
precision highp float;
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;
in vec4 FragPosViewSpace;

uniform sampler2D diffuseTexture;
uniform sampler2D shadowMap[4];

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform mat4 lightSpaceMatrices[4];
uniform float cascadePlaneDistances[4];
uniform int cascadeCount;
uniform bool showCascades;
uniform float farPlane;
uniform vec2 shadowMapSize;

float SampleShadowMap(int cascadeIndex, vec2 uv)
{
    if(cascadeIndex == 0)
        return texture(shadowMap[0], uv).r;
    else if(cascadeIndex == 1)
        return texture(shadowMap[1], uv).r;
    else
        if(cascadeIndex == 2)
            return texture(shadowMap[2], uv).r;
        else if(cascadeIndex == 3)
            return texture(shadowMap[3], uv).r;
    
    return texture(shadowMap[0], uv).r;
}

float ShadowCalculation2(int cascadeIndex, vec4 fragPosLightSpace)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    if(projCoords.z > 1.0)
        return 0.0;
    
    if(projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    
    float closestDepth = SampleShadowMap(cascadeIndex, projCoords.xy); 
    float currentDepth = projCoords.z;
    
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    
    // Bias melhorado: constante + slope, com tan(acos) para precisão em ângulos
    float cosTheta = max(dot(normal, lightDir), 0.0);
    float slopeBias = 0.001 * tan(acos(cosTheta));  // Mantido, mas agora somado a constante
    float constantBias = 0.0005;  // Adicionado: bias fixo para superfícies planas
    float baseBias = constantBias + slopeBias;
    
    // Escala adaptativa por cascata: projeta bias de mundo para espaço de profundidade
    // Usa a distância da cascata para escalar (maior bias em mundo para cascatas distantes)
    float cascadeDistance = (cascadeIndex == cascadeCount - 1) ? farPlane : cascadePlaneDistances[cascadeIndex];
    float depthScale = cascadeDistance / farPlane;  // Normaliza pela far plane total
    const float worldBiasFactor = 0.02;  // Ajuste em unidades de mundo (tune isso!)
    float worldBias = worldBiasFactor * depthScale;  // Bias maior para distâncias maiores
    
    // Projeta para espaço de profundidade (aproximação simples via derivada de profundidade)
    float depthBias = baseBias + (worldBias / (farPlane * 100.0));  // Escala para [0-1]; ajuste o 100.0 pela resolução
    
    // Clamp para evitar exageros (descomentei e ajustei baseado em testes comuns)
    depthBias = clamp(depthBias, 0.0001, 0.005 * depthScale);  // Menor clamp para cascatas próximas, maior para distantes
    
    // Ajuste final por resolução do shadow map (opcional, mas melhora em resoluções baixas)
    vec2 texelSize = 1.0 / shadowMapSize;
    depthBias *= (1.0 + texelSize.x * 2.0);  // Fator pequeno baseado em texel para anti-acne
 
    float shadow = 0.0;
    vec2 texelSizePCF = 1.0 / shadowMapSize;
    int pcfCount = 2;
    int numSamples = (pcfCount * 2 + 1) * (pcfCount * 2 + 1);
    
    for(int x = -pcfCount; x <= pcfCount; ++x)
    {
        for(int y = -pcfCount; y <= pcfCount; ++y)
        {
            float pcfDepth = SampleShadowMap(cascadeIndex, projCoords.xy + vec2(x, y) * texelSizePCF); 
            shadow += currentDepth - depthBias > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    shadow /= float(numSamples);
    
    return shadow;
}

float ShadowCalculation(int cascadeIndex, vec4 fragPosLightSpace)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    if(projCoords.z > 1.0)
        return 0.0;
    
    if(projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    
    float closestDepth = SampleShadowMap(cascadeIndex, projCoords.xy); 
    float currentDepth = projCoords.z;
    
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    
    // Bias melhorado baseado no slope
    //float bias = max(0.05 * (1.0 - dot(normal, lightDir)), 0.005);
    //float bias = max(0.08 * (1.0 - dot(normal, lightDir)), 0.008);  
    float cosTheta = max(dot(normal, lightDir), 0.0);
    float bias = 0.001 * tan(acos(cosTheta));
    
    const float biasModifier = 0.5;
    if (cascadeIndex == cascadeCount - 1)
    {
        bias *= 1.0 / (farPlane * biasModifier);
    } 
    else if (cascadeIndex == 0)
    {
         bias = 0.0009;
    } 
    else 
    {
        bias *= 1.0 / (cascadePlaneDistances[cascadeIndex] * biasModifier);
    }

 
   // bias = clamp(bias, 0.0001, 0.01);
   bias = clamp(bias, 0.00005, 0.01);
    
  
    float shadow = 0.0;
    vec2 texelSize = 1.0 / shadowMapSize;
    int pcfCount = 2;
    int numSamples = (pcfCount * 2 + 1) * (pcfCount * 2 + 1);
    
    for(int x = -pcfCount; x <= pcfCount; ++x)
    {
        for(int y = -pcfCount; y <= pcfCount; ++y)
        {
            float pcfDepth = SampleShadowMap(cascadeIndex, projCoords.xy + vec2(x, y) * texelSize); 
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    shadow /= float(numSamples);
    
    return shadow;
}


vec3 GetCascadeColor(int cascadeIndex)
{
    if(cascadeIndex == 0)
        return vec3(1.0, 0.0, 0.0); // Vermelho
    else if(cascadeIndex == 1)
        return vec3(0.0, 1.0, 0.0); // Verde
    else if(cascadeIndex == 2)
        return vec3(0.0, 0.0, 1.0); // Azul
    else
        if (cascadeIndex == 3)
            return vec3(1.0, 1.0, 0.0); // Amarelo
    return vec3(1.0, 1.0, 1.0);
}

void main()
{           
    vec3 color = texture(diffuseTexture, TexCoords).rgb;
    vec3 normal = normalize(Normal);
    vec3 lightColor = vec3(1.0);
    
    // Ambient
    vec3 ambient = 0.15 * lightColor;
    
    // Diffuse
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    float spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
    vec3 specular = spec * lightColor;    
    
    // Selecionar cascata baseado na profundidade
    float depthValue = abs(FragPosViewSpace.z);
    int cascadeIndex = -1;
    
    for(int i = 0; i < cascadeCount - 1; ++i)
    {
        if(depthValue < cascadePlaneDistances[i])
        {
            cascadeIndex = i ;
            break;
        }
    }
    
    if(cascadeIndex == -1)
    {
        cascadeIndex = cascadeCount ;
    }
    
    // Calcular sombra
    vec4 fragPosLightSpace = lightSpaceMatrices[cascadeIndex] * vec4(FragPos, 1.0);
    float shadow = ShadowCalculation(cascadeIndex, fragPosLightSpace);
    
    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;
    
    // Visualização de cascatas (debug)
    if(showCascades)
    {
        lighting *= GetCascadeColor(cascadeIndex);
    }
    
    FragColor = vec4(lighting, 1.0);
}
)";



























const char *shadowFragmentShader = R"(
#version 300 es
precision highp float;
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;
in vec4 FragPosViewSpace;

uniform sampler2D diffuseTexture;
uniform sampler2D shadowMap[4];

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform mat4 lightSpaceMatrices[4];
uniform float cascadePlaneDistances[4];
uniform int cascadeCount;
uniform bool showCascades;
uniform float farPlane;
uniform vec2 shadowMapSize;


uniform float debugBaseBias;        // Controlar baseBias
uniform float debugSlopeBias;       // Controlar slopeBias
uniform float debugNormalOffset;    // Controlar normal offset
uniform float debugDiskRadius;      // Controlar Poisson disk radius

const vec2 poissonDisk[16] = vec2[](
   vec2(-0.94201624, -0.39906216),
   vec2(0.94558609, -0.76890725),
   vec2(-0.094184101, -0.92938870),
   vec2(0.34495938, 0.29387760),
   vec2(-0.91588581, 0.45771432),
   vec2(-0.81544232, -0.87912464),
   vec2(-0.38277543, 0.27676845),
   vec2(0.97484398, 0.75648379),
   vec2(0.44323325, -0.97511554),
   vec2(0.53742981, -0.47373420),
   vec2(-0.26496911, -0.41893023),
   vec2(0.79197514, 0.19090188),
   vec2(-0.24188840, 0.99706507),
   vec2(-0.81409955, 0.91437590),
   vec2(0.19984126, 0.78641367),
   vec2(0.14383161, -0.14100790)
);

float SampleShadowMap(int cascadeIndex, vec2 uv)
{
    if(cascadeIndex == 0)
        return texture(shadowMap[0], uv).r;
    else if(cascadeIndex == 1)
        return texture(shadowMap[1], uv).r;
    else
        if(cascadeIndex == 2)
            return texture(shadowMap[2], uv).r;
        else if(cascadeIndex == 3)
            return texture(shadowMap[3], uv).r;
    
    return texture(shadowMap[0], uv).r;
}


float ShadowCalculationDiskPCF(int cascadeIndex, vec4 fragPosLightSpace)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    if(projCoords.z > 1.0)
        return 0.0;
    
    if(projCoords.x < 0.0 || projCoords.x > 1.0 || 
       projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    
    float currentDepth = projCoords.z;
    
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float NdotL = max(dot(normal, lightDir), 0.0);
    
    // Bias otimizado
    float baseBias = 0.0002;
    float slopeBias = 0.0005 * (1.0 - NdotL);
    float cascadeScale = 1.0 + float(cascadeIndex) * 0.2;
    float bias = (baseBias + slopeBias) * cascadeScale;
    bias = clamp(bias, 0.00005, 0.0015);
    
   
    float shadow = 0.0;
    vec2 texelSize = 1.0 / shadowMapSize;
    float diskRadius = 3.5;  // Ajustar entre 2.0 e 3.5
    
    for(int i = 0; i < 16; ++i)
    {
        vec2 offset = poissonDisk[i] * texelSize * diskRadius;
        float pcfDepth = SampleShadowMap(cascadeIndex, projCoords.xy + offset);
        shadow += (currentDepth - bias) > pcfDepth ? 1.0 : 0.0;
    }
    shadow /= 16.0;
    
    return shadow;
}

float ShadowCalculationPCF(int cascadeIndex, vec4 fragPosLightSpace)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    if(projCoords.z > 1.0)
        return 0.0;
    
    if(projCoords.x < 0.0 || projCoords.x > 1.0 || 
       projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    
    float currentDepth = projCoords.z;
    
    vec3 normal = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float NdotL = max(dot(normal, lightDir), 0.0);
    
    // Bias otimizado para superfícies planas e inclinadas
    float baseBias = 0.0002;  //  Reduzido para menos peter-panning
    float slopeBias = 0.0004 * (1.0 - NdotL);  //  Mais suave
    
    // Escala por cascata (mais conservadora)
    float cascadeScale = 1.0 + float(cascadeIndex) * 0.2;  //  Era 0.3
    float bias = (baseBias + slopeBias) * cascadeScale;
    
    // Clamp mais restrito
    bias = clamp(bias, 0.00005, 0.0012);  //  Limites mais apertados
    
    // PCF com kernel maior para suavizar
    float shadow = 0.0;
    vec2 texelSize = 1.0 / shadowMapSize;
    int pcfCount = 3;  //  Aumentar para 3 (kernel 7x7)
    int numSamples = (pcfCount * 2 + 1) * (pcfCount * 2 + 1);
    
    for(int x = -pcfCount; x <= pcfCount; ++x)
    {
        for(int y = -pcfCount; y <= pcfCount; ++y)
        {
            float pcfDepth = SampleShadowMap(cascadeIndex, projCoords.xy + vec2(x, y) * texelSize); 
            shadow += (currentDepth - bias) > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    shadow /= float(numSamples);
    
    return shadow;
}

float ShadowCalculation(int cascadeIndex, vec4 fragPosLightSpace)
{
    return ShadowCalculationDiskPCF(cascadeIndex, fragPosLightSpace);
}

vec3 GetCascadeColor(int cascadeIndex)
{
    if(cascadeIndex == 0)
        return vec3(1.0, 0.0, 0.0); // Vermelho
    else if(cascadeIndex == 1)
        return vec3(0.0, 1.0, 0.0); // Verde
    else if(cascadeIndex == 2)
        return vec3(0.0, 0.0, 1.0); // Azul
    else
        if (cascadeIndex == 3)
            return vec3(1.0, 1.0, 0.0); // Amarelo
    return vec3(1.0, 1.0, 1.0);
}

void main()
{           
    vec3 color = texture(diffuseTexture, TexCoords).rgb;
    vec3 normal = normalize(Normal);
    vec3 lightColor = vec3(1.0);
    
    // Ambient
    vec3 ambient = 0.15 * lightColor;
    
    // Diffuse
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    float spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
    vec3 specular = spec * lightColor;    
    
    // Selecionar cascata baseado na profundidade
    float depthValue = abs(FragPosViewSpace.z);
    int cascadeIndex = -1;
    
    for(int i = 0; i < cascadeCount; ++i)
    {
        if(depthValue < cascadePlaneDistances[i])
        {
            cascadeIndex = i;
            break;
        }
    }

    if(cascadeIndex == -1)
    {
        cascadeIndex = cascadeCount - 1;
    }
        
    // Calcular sombra
    vec3 offsetFragPos = FragPos + normal * 0.010;  //  Offset pela normal
    vec4 fragPosLightSpace = lightSpaceMatrices[cascadeIndex] * vec4(offsetFragPos, 1.0);
    float shadow = ShadowCalculation(cascadeIndex, fragPosLightSpace);
    
    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;
    
    // Visualização de cascatas (debug)
    if(showCascades)
    {
        lighting *= GetCascadeColor(cascadeIndex);
    }
    
    FragColor = vec4(lighting, 1.0);
}
)";