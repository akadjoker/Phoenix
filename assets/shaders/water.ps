#version 300 es
precision highp float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;


out vec4 ClipSpace;
out vec2 TexCoord;
out vec3 ToCameraVector;
out vec3 WorldPos;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform vec3 cameraPos;

uniform float u_time;
uniform float u_waveLength;
uniform float u_windForce;
uniform vec2  u_windDirection;
uniform float u_waveHeight;
uniform float u_waveSpeed;

uniform int u_numWaves;
uniform vec4 u_wave1; // (directionX, directionY, steepness, wavelength)
uniform vec4 u_wave2;
uniform vec4 u_wave3;
uniform vec4 u_wave4;

out vec2 v_bumpMapTexCoord;
out vec2 v_mapTexCoord;
out vec3 v_normal;



const float PI = 3.14159265359;

 
vec3 GerstnerWave(vec2 position, vec2 direction, float steepness, float wavelength, float time)
{
    float k = 2.0 * PI / wavelength; // Wave number
    float c = sqrt(9.8 / k); // Wave speed (f√≠sica real!)
    vec2 d = normalize(direction);
    float f = k * (dot(d, position) - c * time);
    float a = steepness / k;
    
    // Deslocamento da onda
    return vec3(
        d.x * a * cos(f),           // X displacement
        a * sin(f),                 // Y displacement (altura)
        d.y * a * cos(f)            // Z displacement
    );
}

 
vec3 GerstnerWaveNormal(vec2 position, vec2 direction, float steepness, float wavelength, float time)
{
    float k = 2.0 * PI / wavelength;
    float c = sqrt(9.8 / k);
    vec2 d = normalize(direction);
    float f = k * (dot(d, position) - c * time);
    float a = steepness / k;
    
    // Derivadas para calcular normal
    float dx = -d.x * d.x * steepness * sin(f);
    float dy = steepness * cos(f);
    float dz = -d.x * d.y * steepness * sin(f);
    
    return vec3(-dx, 1.0, -dz);
}

 

    
void main() 
{
    vec3 pos = aPos;
    vec3 normal = aNormal;

     vec3 waveOffset = vec3(0.0);
    vec3 waveNormal = vec3(0.0, 1.0, 0.0);
    
    // Onda 1
    waveOffset += GerstnerWave(pos.xz, u_wave1.xy, u_wave1.z, u_wave1.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave1.xy, u_wave1.z, u_wave1.w, u_time);
    
    // Onda 2
    waveOffset += GerstnerWave(pos.xz, u_wave2.xy, u_wave2.z, u_wave2.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave2.xy, u_wave2.z, u_wave2.w, u_time);
    
    // Onda 3
    waveOffset += GerstnerWave(pos.xz, u_wave3.xy, u_wave3.z, u_wave3.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave3.xy, u_wave3.z, u_wave3.w, u_time);
    
    // Onda 4
    waveOffset += GerstnerWave(pos.xz, u_wave4.xy, u_wave4.z, u_wave4.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave4.xy, u_wave4.z, u_wave4.w, u_time);
    
    // Aplicar offset
    pos += waveOffset * u_waveHeight;
    normal = normalize(waveNormal);


    vec4 worldPos = model * vec4(pos, 1.0);
    WorldPos = worldPos.xyz;
    ClipSpace = projection * view * worldPos;
    gl_Position = ClipSpace;
    TexCoord = aTexCoord;
    ToCameraVector = cameraPos - worldPos.xyz;
    v_normal = normal;

    v_bumpMapTexCoord = aTexCoord / u_waveLength + u_time * u_windForce * u_windDirection;

}  