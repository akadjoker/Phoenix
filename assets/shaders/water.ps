#version 300 es
precision highp float;

layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;
layout(location = 2) in vec2 aTexCoord;

uniform mat4 model;
uniform mat4 worldViewProj;
uniform mat4 worldReflectionViewProj;

// Propriedades das ondas
uniform float u_time;
uniform float u_waveLength;
uniform float u_windForce;
uniform vec2 u_windDirection;
uniform float u_waveHeight;
uniform float u_waveSpeed;

// Múltiplas ondas (Gerstner Waves)
uniform int u_numWaves;
uniform vec4 u_wave1; // (directionX, directionY, steepness, wavelength)
uniform vec4 u_wave2;
uniform vec4 u_wave3;
uniform vec4 u_wave4;

out vec2 v_bumpMapTexCoord;
out vec3 v_refractionTexCoord;
out vec3 v_reflectionTexCoord;
out vec3 v_position3D;
out vec3 v_normal;

const float PI = 3.14159265359;

// ============================================
// FUNÇÃO: Gerstner Wave (onda realista)
// ============================================
vec3 GerstnerWave(vec2 position, vec2 direction, float steepness, float wavelength, float time)
{
    float k = 2.0 * PI / wavelength; // Wave number
    float c = sqrt(9.8 / k); // Wave speed (física real!)
    vec2 d = normalize(direction);
    float f = k * (dot(d, position) - c * time);
    float a = steepness / k;
    
    // Deslocamento da onda
    return vec3(
        d.x * a * cos(f),           // X displacement
        a * sin(f),                 // Y displacement (altura)
        d.y * a * cos(f)            // Z displacement
    );
}

// ============================================
// FUNÇÃO: Calcular Normal da Onda
// ============================================
vec3 GerstnerWaveNormal(vec2 position, vec2 direction, float steepness, float wavelength, float time)
{
    float k = 2.0 * PI / wavelength;
    float c = sqrt(9.8 / k);
    vec2 d = normalize(direction);
    float f = k * (dot(d, position) - c * time);
    float a = steepness / k;
    
    // Derivadas para calcular normal
    float dx = -d.x * d.x * steepness * sin(f);
    float dy = steepness * cos(f);
    float dz = -d.x * d.y * steepness * sin(f);
    
    return vec3(-dx, 1.0, -dz);
}

// ============================================
// FUNÇÃO: Onda Simples (sin/cos)
// ============================================
vec3 SimpleWave(vec2 position, float time)
{
    float wave1 = sin(position.x * 2.0 + time * 2.0) * 0.1;
    float wave2 = cos(position.y * 3.0 + time * 1.5) * 0.08;
    float wave3 = sin((position.x + position.y) * 1.5 + time * 2.5) * 0.06;
    
    return vec3(0.0, wave1 + wave2 + wave3, 0.0);
}

void main()
{
    vec3 pos = aPos;
    vec3 normal = aNormal;
    
    // ============================================
    // APLICAR ONDAS PROCEDURAIS
    // ============================================
    
    // VERSÃO 1: Ondas simples (rápido)
    // pos += SimpleWave(aPos.xz, u_time);
    
    // VERSÃO 2: Gerstner Waves (realista)
    vec3 waveOffset = vec3(0.0);
    vec3 waveNormal = vec3(0.0, 1.0, 0.0);
    
    // Onda 1
    waveOffset += GerstnerWave(pos.xz, u_wave1.xy, u_wave1.z, u_wave1.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave1.xy, u_wave1.z, u_wave1.w, u_time);
    
    // Onda 2
    waveOffset += GerstnerWave(pos.xz, u_wave2.xy, u_wave2.z, u_wave2.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave2.xy, u_wave2.z, u_wave2.w, u_time);
    
    // Onda 3
    waveOffset += GerstnerWave(pos.xz, u_wave3.xy, u_wave3.z, u_wave3.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave3.xy, u_wave3.z, u_wave3.w, u_time);
    
    // Onda 4
    waveOffset += GerstnerWave(pos.xz, u_wave4.xy, u_wave4.z, u_wave4.w, u_time);
    waveNormal += GerstnerWaveNormal(pos.xz, u_wave4.xy, u_wave4.z, u_wave4.w, u_time);
    
    // Aplicar offset
    pos += waveOffset * u_waveHeight;
    normal = normalize(waveNormal);
    
    // ============================================
    // TRANSFORM
    // ============================================
    vec4 worldPos = model * vec4(pos, 1.0);
    v_position3D = worldPos.xyz;
    v_normal = normal;
    
    // Clip space (normal camera)
    vec4 clipPos = worldViewProj * vec4(pos, 1.0);
    gl_Position = clipPos;
    
    // Bump map UV (animado)
    v_bumpMapTexCoord = aTexCoord / u_waveLength + u_time * u_windForce * u_windDirection;
    
    // Refraction texture coords
    v_refractionTexCoord.x = 0.5 * (clipPos.w + clipPos.x);
    v_refractionTexCoord.y = 0.5 * (clipPos.w + clipPos.y);
    v_refractionTexCoord.z = clipPos.w;
    
    // Reflection texture coords
    vec4 reflectionClipPos = worldReflectionViewProj * vec4(pos, 1.0);
    v_reflectionTexCoord.x = 0.5 * (reflectionClipPos.w + reflectionClipPos.x);
    v_reflectionTexCoord.y = 0.5 * (reflectionClipPos.w + reflectionClipPos.y);
    v_reflectionTexCoord.z = reflectionClipPos.w;
}
